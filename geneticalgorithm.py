# -*- coding: utf-8 -*-
"""
GeneticAlgorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IJxOIJwryd_-lfsXzxfWlXYjaVGfEp3v
    
"""

#%%
import numpy as np
import random
import matplotlib.pyplot as plt
import constraint_conditions as cc
import markov_decision_processes as mdp_module
import disjoint_box_union
import inspect
import importlib
from importlib import reload

from markov_decision_processes import MarkovDecisionProcess as MDP
from disjoint_box_union import DisjointBoxUnion as DBU
import random

reload(disjoint_box_union)
reload(mdp_module)

SEED = 42
random.seed(SEED)
np.random.seed(SEED)

#%%

"""
A genetic algorithm consists of the following operations:

    1. Initialization

    2. Begin a T loop

    3. Fitness evaluation

    4. Crossover

    5. Mutation

    6. Next generation and go back to step 2.
    
    7. Termination condition
"""

#%%

def describe_function(func):
    """Prints a clean summary of a function's signature and docstring."""
    print(f"\nFunction: {func.__name__}")
    print("-" * (len(func.__name__) + 11))

    # Signature
    sig = inspect.signature(func)
    print("Signature:", sig)

    # Parameters
    print("\nParameters:")
    for name, param in sig.parameters.items():
        default = f" = {param.default!r}" if param.default is not inspect._empty else ""
        print(f"  - {name}: kind={param.kind}{default}")

    # Docstring
    doc = inspect.getdoc(func)
    print("\nDocstring:")
    print(doc if doc else "  (No docstring provided)")

#%%

class GeneticAlgorithm:

    def __init__(self, curr_population = [],
                 fitness_function = lambda s : 0.0,
                 crossover_function = lambda s1, s2 : (s1, s2),
                 mutation_function = lambda s : s,
                 initialization_function = lambda s : 0.0,
                 initial_population_size = 10,
                 T = 10,
                 maximize = True,
                 print_fitness = False,
                 tune_fitness_adder = False):

        self.curr_population = curr_population
        self.fitness_function = fitness_function
        self.crossover_function = crossover_function
        self.mutation_function = mutation_function
        self.initialization_function = initialization_function
        self.initial_population_size = initial_population_size
        self.T = T
        self.maximize = maximize
        self.print_fitness = print_fitness
        self.tune_fitness_adder = tune_fitness_adder
        
    def initialize(self):

        return self.initialization_function()

    def evaluate_population_fitness(self):
        '''
        Evaluate the fitness of a population of the population of constraints.
        '''
        fitnesses = []
        for i, elt in enumerate(self.curr_population):
            f = self.fitness_function(elt)
            print(f'Fitness of {elt} is {f}')
            
            fitnesses.append(f)

        self.fitnesses = fitnesses
        return fitnesses

    def find_most_fit_element(self):
        
        fitnesses = self.evaluate_population_fitness()
        if self.maximize:
            return self.curr_population[np.argmax(fitnesses)]
        else:
            return self.curr_population[np.argmin(fitnesses)]

    def sample(self, k):
        """
        Sample k elements from the population weighted by the fitness distribution.
        -----------------------------------------------------------------------
        If maximize=True: higher fitness -> higher probability.
        If maximize=False: lower fitness -> higher probability.
        """

        fitnesses = np.array(self.evaluate_population_fitness(), dtype=float)
        max_fitness = np.max(np.abs(fitnesses))
        
        if np.min(fitnesses) < 0:
            new_fitnesses = max_fitness + fitnesses + 1e-4
        else:    
            new_fitnesses = fitnesses
        
        if self.maximize:
            # Normalize fitness values to probabilities
            probs = new_fitnesses / new_fitnesses.sum()
        else:
            # Inverse fitness: smaller fitness -> larger probability
            inv_fitnesses = 1.0 / (new_fitnesses + 1e-4)   # add epsilon to avoid div by zero
            probs = inv_fitnesses / inv_fitnesses.sum()

        # Debugging: check probabilities
        # print("Probabilities:", probs, "Sum:", probs.sum())

        samples = np.random.choice(
            self.curr_population,
            size=k,
            replace=False,
            p=probs
            )

        return samples


    def crossover(self):
        '''
        Perform crossover on the current population.
        '''
        picked_family = self.sample(k=2)
        remaining = np.setdiff1d(self.curr_population, picked_family, assume_unique=True)
        children = self.crossover_function(picked_family[0], picked_family[1])

        return list(remaining) + list(children)

    
    def print_population_fitness(self):
        
        '''
        Given the population, evaluate and print the fitness of each indiviual
        in the population
        
        '''
        for i, elt in enumerate(self.curr_population):
            
            print(f'Population element is {elt}')
            print(f'Element fitness is {self.fitness_function(elt)}')
            

    def mutate(self, t):
        '''
        Perform mutation on the current population.
        '''
        picked_element = self.sample(k=1)[0]
        mutated_element = self.mutation_function(picked_element, t)
        remaining = np.setdiff1d(self.curr_population, picked_element,
                                 assume_unique = True)

        return list(remaining) + [mutated_element]

    def begin_algorithm(self):

        self.curr_population = self.initialize()

        for t in range(self.T):
            
            fitnesses = self.evaluate_population_fitness()
            print('Fitnesses after evaluation is')
            print(fitnesses)
            
            crossover_population = self.crossover()
            
            if self.print_fitness:
                self.print_population_fitness()
            
            mutated_population = self.mutate()

        return self.curr_population

#%%
"""
List based subroutine example:

In the list based subroutine example, we have that:

*   **Initialization_function** : Create initialization_number ($N$) number of constraint conditions $[a_{i1}, b_{i1}] \times [a_{i2}, b_{i2}] \times ... \times [a_{ik}, b_{ik}]$.

*   **Mutation_function** : Given an element $s := [a_{i1}, b_{i1}] \times [a_{i2}, b_{i2}] \times ... \times [a_{ik}, b_{ik}] \mapsto  [a_{i1}, b_{i1}] \times [a_{i2}, b_{i2}] \times ... \times [a_{ir} + \epsilon_1, b_{ir} + \epsilon_2] ... \times [a_{ik}, b_{ik}]$, where $r$ is a randomly chosen index in $[i1,i2,...,ik]$, where $\epsilon_1$ or $\epsilon_2$ is $0$, otherwise they are distributed normally.

*   **Fitness_function** : Given a sub-interval $[a_{i1}, b_{i1}] \times [a_{i2}, b_{i2}] \times ... \times [a_{ik}, b_{ik}]$ and if the remaining space is $S$, we compute the integral of the adjusted Bellman equations over the set difference:
\begin{equation}
    R := [a_{i1}, b_{i1}] \times [a_{i2}, b_{i2}] \times ... \times [a_{ik}, b_{ik}] \mapsto \int_{R - S} ( \max_{\alpha} [r_t(s,\alpha) + \gamma P^{\alpha}_t V_{t+1}(s)] - [r_t(s,a) + \gamma P^a_t V_{t+1}(s)] - \eta)ds + \rho c(R)
\end{equation}
In the trajectory integral notation, the above looks like:
\begin{equation}
    R := [a_{i1}, b_{i1}] \times [a_{i2}, b_{i2}] \times ... \times [a_{ik}, b_{ik}] \mapsto \sum_{i=1}^N [ \max_{\alpha} [r_t(X_{it},\alpha) + \gamma P^{\alpha}_t V_{t+1}(X_{it})] - [r_t(X_{it},A_{it}) + \gamma P^{A_{it}}_t V_{t+1}(X_{it})] - \eta]\mathcal{I}[X_{it} \in R-S] + \rho c(R)
\end{equation}


*   **Crossover_function** : Given subintervals $[a_{i1}, b_{i1}] \times [a_{i2}, b_{i2}] \times ... \times [a_{ik}, b_{ik}]$ and $[a_{j1}, b_{j1}] \times [a_{j2}, b_{j2}] \times ... \times [a_{jk}, b_{jk}]$, we cross these over by picking indices $r_1$ and $r_2$ in each of the sub-intervals, we would then switch the subintervals corresponding to these intervals:

\begin{equation}
\begin{aligned}
    &([a_{i1}, b_{i1}] \times [a_{i2}, b_{i2}] \times \cdots \times [a_{r1}, b_{r1}] \times \cdots \times [a_{ik}, b_{ik}]) \\
    &\;\;\propto ([a_{j1}, b_{j1}] \times [a_{j2}, b_{j2}] \times \cdots \times [a_{r2}, b_{r2}] \times \cdots \times [a_{jl}, b_{jl}]) \\
    &\;\;:= \bigl([a_{i1}, b_{i1}] \times [a_{i2}, b_{i2}] \times \cdots \times [a_{r2}, b_{r2}] \times \cdots \times [a_{ik}, b_{ik}]\bigr) \\
    &\;\;\;\;\;\;\times \bigl([a_{j1}, b_{j1}] \times [a_{j2}, b_{j2}] \times \cdots \times [a_{r1}, b_{r1}] \times \cdots \times [a_{jl}, b_{jl}]\bigr)
\end{aligned}
\end{equation}
"""

#%%

class ListBasedSubroutine(GeneticAlgorithm):
    '''
    Code to solve the optimization problem at the t'th timestep and the l'th
    lengthstep. We list the code to solve the following problem using a Genetic
    programming technique:

    \begin{equation}
        \int_{R - G^t_l} (max_{\alpha} [r_t(s,\alpha) + \gamma P^{\alpha}_t V_{t+1}(s)] - [r_t(s,a) +
        \gamma P^{a}_{t+1} V_{t+1}(s)] - \eta) ds + \rho c(R)
    \end{equation}

    In the above, we minimize over all possible regions $R$. Assume the state space
    has dimension $d$.

    We solve the problem by doing the following:

    1. Initialize random constraints of dimension $k < d$:
       $[a_{i1}, b_{i1}] \times [a_{i2}, b_{i2}] \times ... \times [a_{ik}, b_{ik]$

    2. Begin a loop of timestep $T$

    3. Evaluate fitness of the general population and weigh things accordingly

    4. Sample a couple of parents from the population according to the weights as
    dictated above; perform crossover to create the new generation

    5. Perform a mutation in the new generation

    6. Go back to step 2.

    '''

    def __init__(self, dimension, action, remaining_space, bounds, stepsizes,
                 timestep, bellman_equation, bellman_equation_I, maximum_over_actions, fix_a,
                 eta, rho, integration_method = 'traj_integral', curr_population = [],
                 obs_states = [], mutation_noises = 0.1, T = 10, maximize = True,
                 initialization_limit = 10, mutation_limit = 10, crossover_limit = 10,
                 valid = True, fitness_adder = 0.0, print_fitness = False, visualize = False,
                 save_time = 10):

        '''
        Compute the interpretable policies for the different length and timesteps
        given a DBUMarkovDecisionProcess.

        Parameters:
        ------------------------------------------------------------------------
        dimension : int
                    The dimension of the space

        action : np.array
                 The action we evaluate the objective on

 remaining_space : DisjointBoxUnion
                   The remaining space at the given length and timestep

        bounds : np.array[dimension,2]
                 The bounds of the space

        stepsizes : np.array[dimension]
                    The stepsizes of the space

     timestep : int
                The timestep we are at when we consider the VIDTR.

     bellman_equation : func(s,a)
                        The bellman we consider for the given time and lengthstep

    bellman_equation_I : func(s,a)
                         The interpretable bellman equation we consider for the
                         given time and lengthstep

    maximum_over_actions : func(f : (s,a) \to R \to R)
                           The maximum over actions function for the given time
                           and lengthstep

    fix_a : func(f: (s,a) \to R) -> f : s \to R
            The functional which converts a function from S \times A to the real,
            to a function from S to the real numbers

integration_method : string
                     The method we use for integration at the current time and
                     lengthstep

    curr_population : list[constraint_conditions]
                      The population of constraints we start out with

    obs_states : list[list]
                 The states that we observe at each time and lengthstep

    mutation_noises : float
                     The noise in the mutation is given by N(0,mutation_noises)
        T : int
            The number of iterations we run the evolution algorithm for
    
    maximize : bool
               Aim to maximize or minimize the fitness over the population
    
 initialization_limit : int
                        The maximum number of initialization tries we run to get an object outside of remaining space;
                        if not possible valid = False
    
    mutation_limit : int
                     The maximum number of mutation tries we run to get an object outside of remaining space;
                     if not possible valid = False
    
    crossover_limit : int
                      The maximum number of crossover tries we run to get an object outside of remaining space;
                      if not possible valid = False
        
        valid : bool
                Is it possible to create an object obeying the following constraints
        
    fitness_adder : float
                    The constant we add to the fitness function to ensure positivity
        
    print_fitness : bool
                    Whether we print the fitness after each iteration of the population        

        '''

        self.dimension = dimension
        self.action = action
        self.remaining_space = remaining_space
        self.bounds = bounds
        self.stepsizes = stepsizes
        self.timestep = timestep
        self.eta = eta
        self.rho = rho
        
        if type(mutation_noises) == int or type(mutation_noises) == float:
            mutation_noises = [mutation_noises for t in range(T)]
        
        self.mutation_noises = mutation_noises
        
        self.T = T
        self.initialization_limit = initialization_limit
        self.mutation_limit = mutation_limit
        self.crossover_limit = crossover_limit
        self.maximize = maximize
        self.valid = valid
        self.fitness_adder = fitness_adder
        self.print_fitness = print_fitness
        self.visualize = visualize
        self.save_time = save_time
        
        def bellman_error(constraint):

            t = timestep
            a = action
            
            cond_DBU = DBU.condition_to_DBU(constraint, stepsizes)
            
            integration_region = cond_DBU.intersect_DBUs(remaining_space)
            
            print('Constraint has non_zero_indices and bounds as follows')
            print(constraint.non_zero_indices, constraint.bounds)
            
            print('We intersect')
            print(cond_DBU)
            
            print('AKA')
            print(constraint)
            
            print('with')
            print(remaining_space)
            
            print('Integration region is')
            print(integration_region)
            
            maxim_bellman_function = lambda s: maximum_over_actions(bellman_equation, t)(s)
            fixed_bellman_function = lambda s: -fix_a(bellman_equation_I, a=a)(s)
            total_bellman_function = lambda s: maxim_bellman_function(s) + fixed_bellman_function(s)

            if integration_method == 'traj_integral':
                bellman_error = DBU.trajectory_integrate(obs_states,
                                                         total_bellman_function,
                                                         integration_region,
                                                         t)
            else:
                 bellman_error = DBU.integrate_static(integration_region,
                                                      total_bellman_function,
                                                      check_positivity=True
                                                      )

            N = integration_region.no_of_points()
            const_error = - N * eta
            complexity_error = rho * cond_DBU.complexity
            error = (bellman_error + const_error + complexity_error)
            error += fitness_adder
            
            return error

        def mutation_function(constraint, t):

            index_1 = random.choice(np.arange(len(constraint.non_zero_indices)))
            x = np.random.binomial(1, p=0.5)

            new_bounds = constraint.bounds[index_1, x] + np.random.normal(0, mutation_noises[t])
            new_constraint = cc.ConstraintConditions(dimension, constraint.non_zero_indices,
                                                     new_bounds)

            new_DBU = DBU.condition_to_DBU(constraint, self.stepsizes)
            
            mutation_count = 0
            
            while not new_DBU.present_inside(remaining_space):
                
                mutation_count += 1
                if mutation_count > self.mutation_limit:
                    print('Mutation count has now crossed the mutation limit')
                    self.valid = False
                    self.error = 'Mutation_count'
                    break
                
                index_1 = random.choice(np.arange(len(constraint.non_zero_indices)))
                x = np.random.binomial(1, p=0.5)

                new_bounds = constraint.bounds[index_1, x] + np.random.normal(0, mutation_noises[t])
                new_constraint = cc.ConstraintConditions(dimension, constraint.non_zero_indices,
                                                         new_bounds)

                new_DBU = DBU.condition_to_DBU(constraint, self.stepsizes)
            
            return new_constraint

        def constraint_crossover(constraint1, constraint2):

            i1, index1 = random.choice(list(enumerate(constraint1.non_zero_indices)))
            i2, index2 = random.choice(list(enumerate(constraint2.non_zero_indices)))

            bounds1 = constraint1.bounds[i1]
            bounds2 = constraint2.bounds[i2]

            non_zero_indices1 = constraint1.non_zero_indices
            non_zero_indices2 = constraint2.non_zero_indices

            new_bounds1 = constraint1.bounds.copy()
            new_bounds2 = constraint2.bounds.copy()

            new_bounds1[i1] = bounds2[i2]
            new_bounds2[i2] = bounds1[i1]
            
            new_non_zero_indices1 = [i for i in non_zero_indices1 if i != index1] + [index2]
            new_non_zero_indices2 = [i for i in non_zero_indices2 if i != index2] + [index1]

            new_constraint1 = cc.ConstraintConditions(dimension, new_non_zero_indices1,
                                                      new_bounds1)
            
            new_constraint2 = cc.ConstraintConditions(dimension, new_non_zero_indices2,
                                                      new_bounds2)
            
            cond_DBU1 = DBU.condition_to_DBU(new_constraint1, self.stepsizes)
            cond_DBU2 = DBU.condition_to_DBU(new_constraint2, self.stepsizes)
            
            constraint_count = 1
            
            while (not remaining_space.present_inside(cond_DBU1)) or (not remaining_space.present_inside(cond_DBU2)):
                
                constraint_count += 1
                if constraint_count > self.crossover_limit:
                    print('Constraint count has now crossed the crossover limit')
                    self.valid = False
                    self.error = 'Crossover'
                    break
                    
                i1, index1 = random.choice(list(enumerate(constraint1.non_zero_indices)))
                i2, index2 = random.choice(list(enumerate(constraint2.non_zero_indices)))

                bounds1 = constraint1.bounds[i1]
                bounds2 = constraint2.bounds[i2]

                non_zero_indices1 = constraint1.non_zero_indices
                non_zero_indices2 = constraint2.non_zero_indices

                new_bounds1 = constraint1.bounds.copy()
                new_bounds2 = constraint2.bounds.copy()

                new_bounds1[i1] = bounds2[i2]
                new_bounds2[i2] = bounds1[i1]
                
                new_non_zero_indices1 = [i for i in non_zero_indices1 if i != index1] + [index2]
                new_non_zero_indices2 = [i for i in non_zero_indices2 if i != index2] + [index1]

                new_constraint1 = cc.ConstraintConditions(dimension, new_non_zero_indices1,
                                                          new_bounds1)
                
                new_constraint2 = cc.ConstraintConditions(dimension, new_non_zero_indices2,
                                                          new_bounds2)
                
                cond_DBU1 = DBU.condition_to_DBU(new_constraint1, self.stepsizes)
                cond_DBU2 = DBU.condition_to_DBU(new_constraint2, self.stepsizes)
                
                
            return new_constraint1, new_constraint2


        def sample_pairs(bounds, stepsizes):
            """
            bounds: np.ndarray of shape (d,2), each row [low, high]
            stepsizes: array-like of length d
            """
            d = bounds.shape[0]

            # 1. Pick random k
            k = random.randint(1, d)

            # 2. Pick k distinct indices
            indices = random.sample(range(d), k)

            # 3. For each index, sample (a_i, b_i)
            result = []
            
            for i in indices:
                
                grid = np.arange(bounds[i, 0], bounds[i, 1], stepsizes[i])
                a = random.choice(grid)
                b = random.choice(grid)
                
                while a==b:
                    a = random.choice(grid)
                    b = random.choice(grid)
                
                if a > b:
                    
                    large_val=a
                    a = b
                    b = large_val
                
                result.append([a, b])

            return np.array(result), indices
        
        def initialization_function():
            
            constraints = []
            for i in range(self.initial_population_size):
                
                constraint_bounds, non_zero_indices = sample_pairs(bounds, stepsizes)
                constraint = cc.ConstraintConditions(dimension, non_zero_indices, constraint_bounds, state_bounds = bounds)
                
                cond_DBU = DBU.condition_to_DBU(constraint, stepsizes)
                
                initialization_count = 0
                while not remaining_space.present_inside(cond_DBU):
                    
                    constraint_bounds, non_zero_indices = sample_pairs(bounds, stepsizes)
                    constraint = cc.ConstraintConditions(dimension, non_zero_indices, constraint_bounds, state_bounds = bounds)
                    
                    cond_DBU = DBU.condition_to_DBU(constraint, stepsizes)
                    
                    initialization_count += 1
                    
                    if initialization_count > self.initialization_limit:
                        print('Initialization count has now crossed initialization limit')
                        self.valid = False
                        self.error = 'Initialization'
                        break
            
                constraints.append(constraint)    
            
            return constraints

        super().__init__(curr_population = curr_population,
                         fitness_function = bellman_error,
                         crossover_function = constraint_crossover,
                         mutation_function = mutation_function,
                         initialization_function = initialization_function,
                         maximize = maximize,
                         T = T)
    
    
    def visualize_population_2D(self, title, save=True):
        '''
        Given the population of constraints visualize the same using matplotlib.pyplot
        '''
        fig, ax = plt.subplots()
    
        for i, c in enumerate(self.curr_population):
            non_zero_indices = c.non_zero_indices
    
            if len(non_zero_indices) < 2:
                if non_zero_indices == [0]:
                    # x is constrained, y=0
                    ax.scatter(c.bounds[0, 0], 0, color="red", label="lower bound" if i == 0 else "")
                    ax.scatter(c.bounds[0, 1], 0, color="blue", label="upper bound" if i == 0 else "")
    
                elif non_zero_indices == [1]:
                    # y is constrained, x=0
                    ax.scatter(0, c.bounds[0, 0], color="red", label="lower bound" if i == 0 else "")
                    ax.scatter(0, c.bounds[0, 1], color="blue", label="upper bound" if i == 0 else "")
    
                else:
                    # both constrained
                    ax.scatter(c.bounds[0, 0], c.bounds[1, 0], color="red", label="lower bound" if i == 0 else "")
                    ax.scatter(c.bounds[0, 1], c.bounds[1, 1], color="blue", label="upper bound" if i == 0 else "")
    
        ax.set_xlabel("x")
        ax.set_ylabel("y")
        ax.legend()
        ax.set_title(title)
        ax.grid(True)
        if save:
            plt.savefig(title)
        plt.show()
    
    def begin_algorithm(self):

        self.curr_population = self.initialize()

        for t in range(self.T):
            
            fitnesses = self.evaluate_population_fitness()
            print('Fitnesses after evaluation is')
            print(fitnesses)
            
            crossover_population = self.crossover()
            
            if self.print_fitness:
                self.print_population_fitness()
            
            mutated_population = self.mutate(t)
            
            title = f'Population at time {t}'
            
            if (self.visualize) and (t % self.save_time == 0):
                self.visualize_population_2D(title = f'Population at time {t}',
                                             save=True)
        
        return self.curr_population    
            
#%%%
